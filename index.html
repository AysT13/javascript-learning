<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript Learning</title>
    <link rel="stylesheet" href="styles.css" />
    <!-- <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet"> -->
  </head>
  <body>
    <h1>JavaScript Learning - Core Topics with Examples</h1>

    <section class="topic">
      <h2>1. Variables (var, let, const)</h2>
      <ul>
        <li>
          <span class="bold">var :</span> Old method - has function scope -
          supports hoisting
        </li>
        <li>
          <span class="bold">let :</span> Modern method - has block scope. Its
          value can be changed later
        </li>
        <li>
          <span class="bold">const :</span> Has block scope- Its value cannot be
          changed - it holds constant data
        </li>
      </ul>
      <pre><code>var name = "Aysen";
console.log(name); // "Aysen"

let age = 42;
age=25; // value can be changed
console.log(age); // 25

const country = "Cyprus";
//country = Netherlands; //Throws an error: const cannot be changed
console.log(country); // "Cyprus"

let and const are only valid within the block they are defined 
if (true) {
  var a = 1; 
  let b = 2;
  const c = 3;
}
console.log(a); // 1  var is function-scoped
//console.log(b); //  Error: b is not defined 
//console.log(c); //  Error: c is not defined
</code></pre>
    </section>

    <section class="topic">
      <h2>2. Data Types</h2>
      <p>
        Basic Data Types: string, number, boolean, null, undefined, object,
        array
      </p>
      <p>Two main groups of data types:</p>
      <ul>
        <p>I.Primitive Types:</p>
        <li><span class="bold">string:</span> Text → "hello"</li>
        <li><span class="bold">number:</span> Number → 25, 3.14</li>
        <li><span class="bold">boolean:</span> True/false → true / false</li>
        <li><span class="bold">undefined:</span> Undefined → let x;</li>
        <li>
          <span class="bold">null:</span> Intentional emptiness → let y = null
        </li>
        <li><span class="bold">symbol (advanced)</span></li>
        <li><span class="bold">bigint (very large numbers)</span></li>
        <p>II.Reference (Non-Primitive) Types:</p>
        <li>
          <span class="bold">object:</span> One of the main building blocks → {
          name: "Aysen" }
        </li>
        <li><span class="bold">array:</span> List structure → [1, 2, 3]</li>
        <li>
          <span class="bold">function:</span> Function → function hello() {}
        </li>
      </ul>
      <p>
        You can find out the data type with the typeof operator. array and
        function are technically of the object type, but they have special
        behaviors.
      </p>
      <pre><code>// Primitive Types
let name = "Aysen";          // string
let age = 30;                // number
let isHappy = true;          // boolean
let job;                     // undefined
let car = null;              // null

console.log(typeof name);    // "string"
console.log(typeof age);     // "number"
console.log(typeof job);     // "undefined"
console.log(typeof car);     // "object" → It is a JavaScript error, null is actually a primitive.

// Non-Primitive Types
let person = { name: "Aysen", age: 30 }; // object
let colors = ["red", "blue", "green"];   // array (in reality, object)
let greet = function() { return "Hi"; }  // function (object)

console.log(typeof person);   // "object"
console.log(typeof colors);   // "object"
console.log(typeof greet);    // "function"
</code></pre>
    </section>

    <section class="topic">
      <h2>3. Operators</h2>
      <p>
        Operators perform actions on variables. They are examined in 3 main
        groups:
      </p>
      <ul>
        <li>Arithmetic Operators (Mathematical operations) + - * / % **</li>
        <li>
          Comparison Operators (Returns true / false) == === != !== > < >= <=
        </li>
        <li>Logical Operators (Used in conditions) && || !</li>
      </ul>

      <pre><code>let a = 10;
let b = "10";

console.log(a == b);   // true 
console.log(a === b);  // false >different type

console.log(a > 5 && a < 15);   // true
console.log(a < 5 || a > 15);   // false

console.log(!true);    // false
console.log(!false);   // true
</code></pre>
    </section>

    <section class="topic">
      <h2>4. Conditional Statements (if, else, else if, switch)</h2>
      <p>
        Conditional statements execute code based on whether a condition is true
        or false
      </p>
      <pre><code>if, else if, else
Conditions are checked sequentially. The first one that is true runs. An if block takes a condition inside parentheses.

let age = 18;
if (age >= 18) {
  console.log("You can vote.");
} else if (age >= 16) {
  console.log("You can drive.");
} else {
  console.log("You are too young.");
}

Switch
It is preferred for checking multiple conditions.
If a break is not used, all the following cases will run (a fall-through error).
The default case runs if no other cases match. Switch statements look cleaner for constant value comparisons.

let day = "Monday";
switch (day) {
  case "Monday":
    console.log("Start of the week");
    break;
  case "Friday":
    console.log("Weekend is coming!");
    break;
  default:
    console.log("Regular day");
    break;}
  </code></pre>
    </section>

    <section class="topic">
      <h2>5.Loops</h2>
      <p>for, while, do while, for...of, for...in</p>
      <p>Loops are used to perform a specific action multiple times.</p>
      <pre><code>for Loop - The classic counting loop:
for (let i = 0; i &lt; 3; i++) {
  console.log("Hello", i);
}
// 0, 1, 2 

while Loop - runs as long as the condition is true:
let i = 0;
while (i &lt; 3) {
  console.log("Hi", i);
  i++;
}

do...while Loop - runs at least once:
let i = 0;
do {
  console.log("Hey", i);
  i++;
} while (i &lt; 3);

for...of - for iterating over an array:
let colors = ["red", "green", "blue"];
for (let color of colors) {
  console.log(color);
}

for...in - for iterating over an object:
let person = { name: "Aysen", age: 30 };
for (let key in person) {
  console.log(key, ":", person[key]);
}
// name: Aysen
// age: 30

break - stops the loop
continue - moves to the next iteration
</code></pre>
    </section>

    <section class="topic">
      <h2>6. Functions</h2>
      <p>
        Functions are blocks of code that you can run over and over. You define
        them once and call them as many times as you need. Functions organize
        code and make it reusable. If you don't use return, the function will
        return undefined. Parameters send data into the function.
      </p>
      <pre><code>Function Definition and Calling:
function greet() {
  console.log("Hello World!");
}
greet();

Functions with Parameters:
function greetPerson(name) {
  console.log("Hello " + name);
}
greetPerson("Aysen"); // "Hello Aysen"
greetPerson("Sahil"); // "Hello Sahil"

Returning a Value with return:
function square(num) {
  return num * num;
}
let result = square(4); // 16
console.log(result);

Default Parameters:
function sayHi(name = "Guest") {
  console.log("Hi " + name);
}
sayHi();         // "Hi Guest"
sayHi("Aysen");  // "Hi Aysen"

Function Expression:
const add = function (a, b) {
  return a + b;
};
console.log(add(2, 3)); // 5</code></pre>
    </section>

    <section class="topic">
      <h2>7. Arrow Function (=>)</h2>
      <p>
        An arrow function is used to write functions in a shorter way. It's
        especially practical for single-line operations.
      </p>
      <pre><code>Classic Function vs. Arrow Function:
// Classic Function
function greet(name) {
  return "Hello " + name;
}

// Arrow Function
const greet = (name) => "Hello " + name;
console.log(greet("Aysen")); // "Hello Aysen"

Single Parameter: Parentheses can be used but are not required.
const square = x => x * x;
console.log(square(4)); // 16

No Parameters: Parentheses are mandatory.
const hello = () => "Hi there!";
console.log(hello()); // "Hi there!"

Multi-line: Curly braces and a return are required.
const sum = (a, b) => {
  let total = a + b;
  return total;
};
console.log(sum(3, 4)); // 7
</code></pre>
    </section>

    <section class="topic">
      <h2>8. Scope: Global and Local Variables</h2>
      <p>
        Scope determines where a variable is defined and from where it can be
        accessed.
      </p>
      <ul>
        Three main types of scope:
        <li>Global Scope (Accessible from anywhere)</li>
        <li>Function Scope (with var)</li>
        <li>Block Scope (with let and const)</li>
      </ul>
      <pre><code>// Global Scope
let name = "Aysen";
function greet() {
  console.log("Hello " + name);
}
greet();           // "Hello Aysen"
console.log(name); // "Aysen"

//Function Scope with var
function test() { 
  var message = "Inside function";
  console.log(message);
}
test();
// console.log(message); // Error! Inaccessible from outside.
//var is only valid inside a function.

//Block Scope with let and const
if (true) {
  let age = 30;
  const city = "Nicosia";
  console.log(age, city); // Accessible
}
// console.log(age); // Error: outside the block
// console.log(city); // Error
//let and const are only valid inside the curly braces where they are defined.
</code></pre>
    </section>

    <section class="topic">
      <h2>9. Hoisting</h2>
      <p>
        Before running your file, JavaScript "hoists" variable and function
        definitions to the top. However, the behavior is different for var, let,
        const, and function.
      </p>
      <p>var Hoisting: The definition is hoisted, but the value is not</p>
      <p>let and const are hoisted, but they cannot be used.</p>
      <p>Functions are fully hoisted (function declaration)</p>
      <p>
        Function expressions are not hoisted. They are variables, so they are
        hoisted like let but cannot be used
      </p>
      <pre><code>console.log(a); // undefined
var a = 5;

//JavaScript sees this as follows:
var a;
console.log(a); // undefined
a = 5;

console.log(b); // Error: Cannot access 'b' before initialization
let b = 10;

sayHi(); // "Hi Aysen"
function sayHi() {
  console.log("Hi Aysen");
}

// greet(); // Error: Cannot access 'greet' before initialization
const greet = function () {
  console.log("Hello!");
};
</code></pre>
    </section>

    <section class="topic">
      <h2>10. Template Literals (`Hello ${name}`)</h2>
      <p>
        Template literals make string concatenation easier and more readable.
        Instead of single quotes (') or double quotes ("), they use backticks
        (`).
      </p>
      <pre><code>//Combining Text with Variables
let name = "Aysen";
let age = 42;
let msg = `My name is ${name} and I am ${age} years old.`;
console.log(msg);
// "My name is Aysen and I am 42 years old."

//Writing Multi-line Text
//You don't need to use \n. The Enter key is enough
let message = `This is line 1
This is line 2
This is line 3`;
console.log(message);

//You Can Also Perform Operations Inside 
let a = 5;
let b = 3;
console.log(`Total: ${a + b}`); // "Total: 8"
</code></pre>
    </section>

    <section class="topic">
      <h2>11. Array Methods</h2>
      <ul>
        <li><span class="bold">push() </span>adds an element to the end</li>
        <li>
          <span class="bold">pop() </span> removes an element from the end
        </li>
        <li>
          <span class="bold">unshift() </span> adds an element to the beginning
        </li>
        <li>
          <span class="bold">shift() </span> removes an element from the
          beginning
        </li>
      </ul>

      <pre><code>let fruits = ["apple", "banana"];
fruits.push("orange");
console.log(fruits); // ["apple", "banana", "orange"]

let colors = ["red", "green", "blue"];
colors.pop();
console.log(colors); // ["red", "green"]

let animals = ["cat", "dog"];
animals.unshift("bird");
console.log(animals); // ["bird", "cat", "dog"]

let cars = ["bmw", "audi", "mercedes"];
cars.shift();
console.log(cars); // ["audi", "mercedes"]
</code></pre>

      <ul>
        <li>
          <span class="bold">forEach() </span> performs an action for
          each element (but doesn't create a new array) -It just performs the
          action; it doesn't return anything or create a new array.
        </li>
        <li>
          <span class="bold">map() </span> transforms each element, returns a
          new array. Takes the result returned for each element and creates a
          new array.
        </li>
        <li>
          <span class="bold">filter() </span>takes elements that meet a
          condition. Elements that don't match the condition are discarded, and
          a new array is returned with only the ones that match.
        </li>
        <li>
          <span class="bold">find() </span>returns the first element that meets
          a condition. While filter returns multiple results, find finds and
          returns the first one that is suitable.
        </li>
      </ul>
      <pre><code>let names = ["Aysen", "Sahil", "Mia"];
names.forEach(function(name) {
  console.log("Hello " + name);
});
// "Hello Aysen", "Hello Sahil", "Hello Mia"

let numbers = [1, 2, 3];
let doubled = numbers.map(function(num) {
  return num * 2;
});
console.log(doubled); // [2, 4, 6]

let numbers = [1, 2, 3, 4, 5];
let evens = numbers.filter(function(num) {
  return num % 2 === 0;
});
console.log(evens); // [2, 4]

let users = [
  { name: "Aysen", age: 30 },
  { name: "Sahil", age: 12 },
  { name: "Mira", age: 30 }
];

let result = users.find(function(user) {
  return user.age === 42;
});
console.log(result); // { name: "Aysen", age: 42 }
</code></pre>

      <ul>
        <li>
          <span class="bold">includes() </span>checks if a value exists (true /
          false). It checks whether a specific value is in the array. It is
          case-sensitive (capitalization matters).
        </li>
        <li>
          <span class="bold">indexOf() </span>returns the index of the value (or
          -1 if not found). It gives the index of the first occurrence. Returns
          -1 if not found.
        </li>
        <li>
          <span class="bold">slice() </span>takes a copy from the array (doesn't
          modify the original).slice(start, end). The end index is not included.
          It does not modify the original array.
        </li>
        <li>
          <span class="bold">splice() </span>modifies the array (add/delete).
          splice(start, deleteCount, item1, item2...).It can both delete and
          add. It modifies the original array.
        </li>
      </ul>

      <pre><code>let colors = ["red", "green", "blue"];
console.log(colors.includes("green")); // true
console.log(colors.includes("yellow")); // false

let animals = ["cat", "dog", "bird"];
console.log(animals.indexOf("dog"));   // 1
console.log(animals.indexOf("lion"));  // -1

let numbers = [1, 2, 3, 4, 5];
let part = numbers.slice(1, 4);
console.log(part);      // [2, 3, 4]
console.log(numbers);   // [1, 2, 3, 4, 5]

let fruits = ["apple", "banana", "cherry"];
// Delete 1 element starting from index 1.
fruits.splice(1, 1);
console.log(fruits); // ["apple", "cherry"]

//Add "orange" at index 1, delete 0 elements.
fruits.splice(1, 0, "orange");
console.log(fruits); // ["apple", "orange", "cherry"]
</code></pre>
    </section>

    <section class="topic">
      <h2>12. Object</h2>
      <p>
        An object is a data type that works with a key-value structure. It is
        not ordered, but it is very organized and used a lot
      </p>
      <pre><code>//Object Creation
const person = {
  name: "Aysen",
  age: 42,
  isStudent: true
};

//Reading Properties (Access)
//Access can be done with dot (.) and bracket ([]) notation.
//If you need to access it with a variable, [] is used.

console.log(person.name);      // "Aysen"
console.log(person["age"]);    // 42

let key = "isStudent";
console.log(person[key]); // true

// Adding / Updating Properties
person.city = "Nicosia";       // Adding a new property
person.age = 30;               // Updating an existing one
console.log(person); //{ name: 'Aysen', age: 30, isStudent: true, city: 'Nicosia' }

//Deleting Properties
delete person.isStudent;
console.log(person); //{ name: 'Aysen', age: 30, city: 'Nicosia' }

//Functions Inside an Object (Method Definition)
//this → accesses the data inside that object.
const user = {
  name: "Aysen",
  greet: function() {
    console.log(`Hi, I am ${this.name}`);
  }
};
user.greet(); // "Hi, I am Aysen"

//Getting all keys and values of an object:
console.log(Object.keys(person));   // ["name", "age", "city"]
console.log(Object.values(person)); // ["Aysen", 42, "Nicosia"]
</code></pre>
    </section>

    <section class="topic">
      <h2>13. Destructuring</h2>
      <p>
        Destructuring is the process of extracting data from an array or object
        into variables in a single line. It makes your code both shorter and
        more readable.
      </p>
      <pre><code>const person = {
  name: "Aysen",
  age: 42,
  city: "Nicosia"
};

//classic way
let name1 = person.name;
let age1 = person.age;

// destructuring: The names must be exactly the same as the keys inside the object.
const { name, age } = person;

console.log(name); // "Aysen"
console.log(age);  // 42

//Retrieving with a new name (alias)
const { name: userName, age: userAge } = person;

console.log(userName); // "Aysen"
console.log(userAge);  // 42

//Array Destructuring
//Order matters. The first element goes to first, and the second goes to second.
const colors = ["red", "green", "blue"];
const [first, second] = colors;

console.log(first);  // "red"
console.log(second); // "green"

//Don't forget to skip variables.
const numbers = [1, 2, 3];
const [ , , third] = numbers;
console.log(third); // 3

//Destructuring in a Function
function printUser({ name, city }) {
  console.log(`${name} lives in ${city}`);
}
printUser(person); // "Aysen lives in Nicosia"
</code></pre>
    </section>

    <section class="topic">
      <h2>14. Spread (...) and Rest (...) Operators</h2>
      <p>
        The three-dot operator (...) can serve both a "spreading" (spread) and
        "collecting" (rest) function. Its use depends on the context.
      </p>
      <pre><code>//Spread Operator (...) - used for "spreading"
//Array concatenation
let arr1 = [1, 2];
let arr2 = [3, 4];
let all = [...arr1, ...arr2];
console.log(all); // [1, 2, 3, 4]

//Object Copying / Merging
//The spread operator doesn't modify the original object; it creates a new copy.
let person = { name: "Aysen", age: 42 };
let updated = { ...person, city: "Nicosia" };
console.log(updated); // { name: "Aysen", age: 42, city: "Nicosia" }

//Spreading arguments in functions.
let numbers = [5, 10];
function sum(a, b) {
  return a + b;
}
console.log(sum(...numbers)); // 15
</code></pre>
      <pre><code>//Rest Operator (...) - used for "collecting"
//As a function parameter:
function addAll(...nums) {
  return nums.reduce((total, num) => total + num, 0);
}
console.log(addAll(1, 2, 3, 4)); // 10
//...nums → collects all incoming numbers like an array.

//Separating some properties from an object:
let { name, ...others } = updated;
console.log(name);    // "Aysen"
console.log(others);  // { age: 42, city: "Nicosia" }
//Here, rest collects the remaining properties as a separate object.
</code></pre>
    </section>

    <section class="topic">
      <h2>15. Ternary Operator (condition ? true : false)</h2>
      <p>
        The ternary operator checks a condition and returns one of two different
        things based on the result. It reduces long if-else blocks to a single
        line.
      </p>
      <pre><code>let age = 18;
let canVote = age >= 18 ? "Yes" : "No";
console.log(canVote); // "Yes"

let isLoggedIn = true;
let message = isLoggedIn ? "Welcome back!" : "Please log in.";
console.log(message); // "Welcome back!"

let score = 85;
let grade = score >= 90 ? "A+" :
            score >= 80 ? "A" :
            score >= 70 ? "B" : "F";
console.log(grade); // "A"

//It's ideal for short and simple conditions. 
//For more complex situations, a classic if-else statement is more readable.
</code></pre>
    </section>

    <section class="topic">
      <h2>16. Short Circuiting and Logical Operators (||, &&)</h2>
      <p>
        || and && don't just compare true / false values; they also direct the
        flow of code and can return a value.
      </p>
      <pre><code>// || (OR):
//Returns the first truthy value.
console.log("Aysen" || "Guest"); // "Aysen"
console.log("" || "Guest");      // "Guest"

//If the left side is falsy, it returns the right side.

// && (AND):
//Returns the first truthy value.
//If all values are truthy, it returns the last value.
console.log(1 && "Hello"); // "Hello"
console.log(0 && "Hi");    // 0

let name = "";
let username = name || "Guest"
console.log(username); // "Guest"

let isLoggedIn = true;
isLoggedIn && console.log("Welcome Aysen!");
//Welcome Aysen!

//&& continues if all conditions are true, 
//but it stops at the first falsy value. 

//Falsy value: false, 0, "", null, undefined, NaN
//Everything else is considered truthy.
</code></pre>
    </section>

    <section class="topic">
      <h2>17. Optional Chaining (?.)</h2>
      <p>
        The ?. operator allows you to safely access properties of an object or
        array that you're not sure exist. If the value doesn't exist, it won't
        throw an error; it will just return undefined.
      </p>
      <pre><code>//Classic Risky Access (Error-Prone)
const user = {};
console.log(user.name); // undefined
console.log(user.name.first); // Error: Cannot read 'first' of undefined

//Safe Access with Optional Chaining
const user = {};
console.log(user?.name?.first); //  undefined (NoError) 
//The ?. operator only accesses a property if it exists. If it doesn't, it stops silently.

const person = {
  name: "Aysen",
  contact: {
    email: "aysen@example.com"
  }
};
console.log(person.contact?.email); // "aysen@example.com"
console.log(person.contact?.phone); // undefined
console.log(person.social?.twitter); //  undefined, (NoError)

const user = {
  sayHi: () => "Hello"
};
console.log(user.sayHi?.()); // "Hello"
console.log(user.sayBye?.()); //  undefined (NoError)

//obj?.key - Gets the key if it exists; otherwise, it returns undefined.
//arr?.[index] - Gets the array element if it exists.
//func?.() - Calls the function if it exists; otherwise, it doesn't.
</code></pre>
    </section>

    <section class="topic">
      <h2>18. Nullish Coalescing Operator (??)</h2>
      <p>
        The ?? operator uses the value on the right only when the value on the
        left is null or undefined. It continues to use the left-hand value for
        all other falsy values (0, "", false).
      </p>
      <pre><code>//The difference with ||:
//The || operator will use the right-hand value for 
 //any falsy value (including 0, "", and false). 
//The ?? operator is more specific and will only use the right-hand value
 //if the left-hand value is null or undefined.
 let name = "";
console.log(name || "Guest"); // "Guest"  ("" = falsy )
console.log(name ?? "Guest"); // "" ("" = Not null)

let userAge = 0;
console.log(userAge || 18);  // 18  (0 = falsy )
console.log(userAge ?? 18);  // 0  (0 = Not Null)

let value = someInput ?? "Default Value";
//someInput → If it is null or undefined, then "Default Value" is used.
</code></pre>
    </section>

    <section class="topic">
      <h2>19. Date & Time Operations</h2>
      <p>The Date object is used for date and time operations.</p>
      <ul>
        <li><span class="bold">new Date() </span>Gives the current date</li>
        <li><span class="bold">getFullYear() </span>Gets the year</li>
        <li><span class="bold">getMonth() </span>Gets the month (0-11)</li>
        <li>
          <span class="bold">getDate() </span>Gets the day of the month (1-31)
        </li>
        <li>
          <span class="bold">getDay() </span> Gets the day of the week (0-6)
        </li>
        <li><span class="bold">Date.now() </span>Gets the current timestamp</li>
      </ul>
      <pre><code>//Getting the Current Date and Time
let now = new Date();
console.log(now); // Mon Aug 06 2025 11:30:00 GMT+0300 (Eastern Europe Time)

console.log(now.getFullYear()); // 2025
console.log(now.getMonth());    // 7 →(Months start from 0: 0 = January)
console.log(now.getDate());     // 5
console.log(now.getDay());      // 2 → (0 = Sunday, 1 = Monday, ...)
console.log(now.getHours());    // 11
console.log(now.getMinutes());  // 30

let birthday = new Date(2013, 11, 11); // December 11, 2013
console.log(birthday.toDateString()); // "Wed Dec 11 2013"

let d1 = new Date("2025-08-01");
let d2 = new Date("2025-08-05");
console.log(d2 > d1); // true

let timestamp = Date.now();
console.log(timestamp); // 1691220000000 

let d = new Date();
let formatted = `${d.getDate()}/${d.getMonth() + 1}/${d.getFullYear()}`;
console.log(formatted); // ex: "6/8/2025"
</code></pre>
    </section>

    <section class="topic">
      <h2>20. Math Methods</h2>
      <p>
        All mathematical operations are performed using the Math object. It
        contains many built-in functions.
      </p>
      <ul>
        <li>
          <span class="bold">Math.random()</span> Generates a random number
          between 0 and 1.
        </li>
        <li>
          <span class="bold">Math.floor()</span>Rounds down to the nearest whole
          number.
        </li>
        <li>
          <span class="bold">Math.ceil()</span>Rounds up to the nearest whole
          number.
        </li>
        <li>
          <span class="bold">Math.round()</span>Rounds to the nearest integer.
        </li>
        <li>
          <span class="bold">Math.min() / Math.max() </span>Returns the smallest
          / largest value.
        </li>
        <li>
          <span class="bold">Math.pow()</span>Raises a base to a given power.
        </li>
        <li>
          <span class="bold">Math.sqrt()</span>Returns the square root of a
          number.
        </li>
      </ul>
      <pre><code>//Random Number - Math.random()
let rnd = Math.random(); //A random number between 0 and 1.
console.log(rnd); 

//generate a random number within a specific range
Math.floor(Math.random() * (max - min + 1)) + min;

//Generate a random number Between 1 and 10
Math.floor(Math.random() * 10) + 1;

//Generate a random number from min to max (inclusive)
Math.floor(Math.random() * (max - min + 1)) + min;

//Generate a random number from min to max (exclusive)
Math.floor(Math.random() * (max - min)) + min;   // [min, max)

//Math.round()
console.log(Math.round(4.5)); // 5
console.log(Math.round(4.4)); // 4

//Math.floor()
console.log(Math.floor(4.9)); // 4

//Math.ceil()
console.log(Math.ceil(4.1)); // 5

//Math.min() -  Math.max()
console.log(Math.min(3, 1, 5)); // 1
console.log(Math.max(3, 1, 5)); // 5

//Math.pow()
console.log(Math.pow(2, 3)); // 8

//Math.sqrt()
console.log(Math.sqrt(9)); // 3
</code></pre>
    </section>

    <section class="topic">
      <h2>
        21. DOM (Document Object Model) Access - (getElementById, querySelector,
        innerText, innerHTML, value ...)
      </h2>
      <p>
        The DOM (Document Object Model) allows you to control an HTML page with
        JavaScript. Everything from clicking buttons and changing text to
        getting form data starts here
      </p>
      <pre><code>//getElementById() - Select an element by its ID
&lt;p id="greeting"&gt;Hello!&lt;/p&gt;
let element = document.getElementById("greeting");
console.log(element.innerText); // "Hello!"

//getElementsByClassName() 
 &lt;p class="text"&gt;This is the first paragraph.&lt;/p&gt;
 &lt;p class="text"&gt;This is the second paragraph.&lt;/p&gt;
//Select all elements with the class "text"
const paragraphs = document.getElementsByClassName("text");

/Can access an individual element using its index:
console.log(paragraphs[0].innerText); // "This is the first paragraph."

//Can also loop through the collection to perform an action on all elements:
for (let i = 0; i &lt; paragraphs.length; i++) {
  // Change the text of each paragraph
  paragraphs[i].innerText = "I changed the text!";
}

//querySelector -Select an element with a CSS selector (id, class, tag)
&lt;p class="msg"&gt;Welcome&lt;/p&gt;
let el = document.querySelector(".msg"); // class selected
console.log(el.innerText); // "Welcome"

&lt;p id="greeting"&gt;Hello! &lt;/p&gt;
&lt;h1&gt;Title&lt;/h1&gt;
let h = document.querySelector("h1"); //selects by tag

//querySelector finds the first match. If there are multiple matches,
//you can get all of them using querySelectorAll.

//Changing Text: innerText and innerHTML
element.innerText = "Merhaba Aysen";   // only Text
element.innerHTML = "&lt;b&gt;Merhaba!&lt;/b&gt;"; //  as HTML 

//Getting the Input Value: value
&lt;input type="text" id="username" value="Aysen"&gt;
let name = document.getElementById("username").value;
console.log(name); // "Aysen"

//Select an Element with JS, Then Perform an Action
&lt;button id="btn"&gt;Click me&lt;/button&gt;
&lt;p id="output">&lt;/p&gt;
document.getElementById("btn").addEventListener("click", function () {
document.getElementById("output").innerText = "You Pressed the button!";});
</code></pre>
    </section>

    <section class="topic">
      <h2>22. Creating / Deleting / Updating Elements in the DOM</h2>
      <ul>
        <li>
          Create an Element -
          <span class="bold">document.createElement("tag")</span>
        </li>
        <li>
          Add to the Page - <span class="bold">appendChild() / append()</span>
        </li>
        <li>
          Remove an Element - <span class="bold">remove() / removeChild()</span>
        </li>
        <li>
          Add an Attribute -
          <span class="bold">setAttribute("name", "value")</span>
        </li>
        <li>
          Add a Class or Style:
          <ul>
            <li>
              - Add a class:
              <span class="bold">element.classList.add("x")</span>
            </li>
            <li>
              - Add a style:
              <span class="bold">element.style.property = "x"</span>
            </li>
          </ul>
        </li>
      </ul>
      <pre><code>//Creating a new Element
let newParagraph = document.createElement("p");  // <p></p>
newParagraph.innerText = "New Paragraph!";

//Adding to the Page - appendChild() or append()
&lt;div id="container"&gt;&lt;/div&gt;
let container = document.getElementById("container");
container.appendChild(newParagraph);// &lt;div&gt;&lt;p&gt;New Paragraph!&lt;/p&gt;&lt;/div&gt;
//With append(), also can add a text node or multiple elements.

//Removing an Element
&lt;p id="removeMe"&gt;Remove Me!&lt;/p&gt;
let element = document.getElementById("removeMe");
element.remove();
//OR
let parent = document.getElementById("container");
let child = document.getElementById("removeMe");
parent.removeChild(child);

//Adding an Attribute
let img = document.createElement("img");
img.setAttribute("src", "./image.jpg");
img.setAttribute("alt", "Definition of Image");

//Adding a Class or Style:
newParagraph.classList.add("highlight");
newParagraph.style.color = "blue";

//Ex: When a button is clicked, add an item to the list:
&lt;ul id="list"&gt;&lt;/ul&gt;
&lt;button id="addBtn"&gt;Add&lt;/button&gt;

document.getElementById("addBtn").addEventListener("click", function () {
  let li = document.createElement("li");
  li.innerText = "New item";
  document.getElementById("list").appendChild(li);
});
</code></pre>
    </section>

    <section class="topic">
      <h2>23. Event Listener</h2>
      <p>
        The addEventListener() method attaches an event to an HTML element. It
        reacts to events like "when a button is clicked," "when something is
        typed into an input," or "when a form is submitted."
      </p>
      <p>
        The Event Object (event or e) - Every event listener receives an event
        object. (e.target.value) returns the text from the input.
      </p>
      <ul>
        <li><span class="bold">click </span>When an element is clicked</li>
        <li>
          <span class="bold">input </span>When text is typed into an input field
        </li>
        <li><span class="bold">submit </span>When a form is submitted</li>
        <li>
          <span class="bold">change </span>When a selection, checkbox, etc., is
          changed
        </li>
        <li>
          <span class="bold">mouseover</span> When the mouse hovers over it
        </li>
        <li>
          <span class="bold">keydown</span> When a keyboard key is pressed
        </li>
      </ul>
      <pre><code>// click - When an element is clicked
&lt;button id="myBtn"&gt;Click&lt;/button&gt;
document.getElementById("myBtn").addEventListener("click", function () {
alert("Clicked!");
});

//input - When text is typed into an input field
&lt;input type="text" id="nameInput" /&gt;
&lt;p id="output">&lt;/p&gt;
document.getElementById("nameInput").addEventListener("input", function (e) {
 document.getElementById("output").innerText = e.target.value;
});

//submit - When a form is submitted
&lt;form id="myForm"&gt;
  &lt;input type="text" name="email" /&gt;
  &lt;button type="submit">Submit&lt;/button&gt;
&lt;/form&gt;
document.getElementById("myForm").addEventListener("submit", function (e) {
  e.preventDefault(); // Prevents the page from refreshing
  alert("Form submitted!");
});

//change -  The change event fires when the value of an 
//HTML element is changed and the change is "committed."
//This is different from the input event, 
//which fires every time you type a character. 
//The change event only fires when you are done making changes.
// &lt;input type="text" id="myInput"&gt;
const inputElement = document.getElementById('myInput');
inputElement.addEventListener("change", function (e) {
  console.log(e.target); // Gives the element whose value was changed
});
</code></pre>
    </section>

    <section class="topic">
      <h2>24. Form Validation</h2>
      <p>
        Form validation checks whether the fields in a form comply with the
        rules before the form is submitted. You can write your own rules and
        provide warnings to the user. Also can use tools like Regular
        Expressions (Regex) to define specific patterns for things like email
        addresses, phone numbers or passwords.
      </p>
      <pre><code>//Check for Empty Fields
&lt;form id="myForm"&gt;
  &lt;input type="text" id="username" placeholder="Enter your Username"/&gt;
  &lt;button type="submit">Submit&lt;/button&gt;
&lt;/form&gt;
&lt;p id="errorMsg"&gt;&lt;/p&gt;

document.getElementById("myForm").addEventListener("submit", function (e) {
  // Prevents the page from refreshing
  e.preventDefault(); 
  let username = document.getElementById("username").value;
  if (username === "") {
    document.getElementById("errorMsg").innerText = "Username cannot be empty!";
  } else {
    document.getElementById("errorMsg").innerText = "";
    alert("Form submitted!");
  }
});

//By using e.preventDefault(), you stop a form's default 
//submission behavior which would normally refresh the page allowing
//you to run your own JavaScript validation code first.

//Email Format Check (with Regex)
&lt;input type="email" id="email" placeholder="Enter email" /&gt;
&lt;p id="emailError">&lt;/p&gt;

let email = document.getElementById("email").value;
// A basic regex pattern for email validation
let emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
if (!emailPattern.test(email)) {
  document.getElementById("emailError").innerText = "Invalid email!";
}

//Password Length Check
&lt;input type="password" id="password" /&gt;
&lt;p id="passError">&lt;/p&gt;

let password = document.getElementById("password").value;
if (password.length &lt; 6) {
  document.getElementById("passError").innerText = "Password must be at least 6 characters";
}
</code></pre>
    </section>

    <section class="topic">
      <h2>25. Modifying Classes and Styles (classList & style)</h2>
      <p>
        <span class="bold">classList </span>and
        <span class="bold">style </span>are used to dynamically add, remove, or
        change classes and apply styles to HTML elements.
      </p>
      <ul>
        <li><span class="bold">classList.add() </span>Adds a class</li>
        <li><span class="bold">classList.remove() </span>Removes a class</li>
        <li>
          <span class="bold">classList.toggle() </span>Removes if it exists, adds
          if not
        </li>
        <li>
          <span class="bold">element.style.property </span>Applies CSS directly
        </li>
        <p>
          Use classList for fixed designs, and style for small, instant changes.
        </p>
      </ul>
      <pre><code>// classList.add()
//html
&lt;p id="text"&gt;Hello!&lt;/p&gt;
//css
.red {
  color: red;
}
//js
document.getElementById("text").classList.add("red");

//classList.remove() 
document.getElementById("text").classList.remove("red");

//classList.toggle()
document.getElementById("text").classList.toggle("red");
//for situations like toggling on/off or 
//showing/hiding content with a single button.

let el = document.getElementById("text");
el.style.color = "blue";
el.style.fontSize = "20px";

//Change text color with a button
&lt;p id="text"&gt;Hello Aysen!&lt;/p&gt;
&lt;button id="changeColor"&gt;Change Color&lt;/button&gt;

document.getElementById("changeColor").addEventListener("click", function () {
  document.getElementById("text").classList.toggle("red");
});
//.toggle("red") is the key method. It checks the paragraph:
//If the red class is already there, it removes it.
//If the red class is not there, it adds it.

//The JavaScript's only job is to add or remove the class.
// For this to have a visual effect, you must have a CSS rule 
//that defines what the .red class does.
</code></pre>
    </section>





<section class="topic">
      <h2>26. Functional Programming (map(), filter(), reduce(), sort())</h2>
    <p>Functional programming uses functions like map, filter, and reduce to transform data.
It avoids changing the original array and helps write clean, reusable code.</p>
<p>sort() reorders elements but changes the original array, unlike map or filter.</p>
       <ul>
    <li><span class="bold">map() </span> change every item - returns new array</li>
    <li><span class="bold">filter() </span>  keep some items - returns new array</li>
    <li><span class="bold">reduce() </span>  get one final value - returns one value</li>
    <li><span class="bold">sort() </span>  rearrange items - changes array</li>
  </ul>
      <pre><code>// map() - Changes every item and returns a new array 
const nums = [1, 2, 3];
const squares = nums.map(n => n * n);
console.log(squares); // [1, 4, 9]

// filter() - Selects items that match a condition and returns a new array.
const values = [1, 2, 3, 4, 5];
const even = values.filter(n => n % 2 === 0);
console.log(even); // [2, 4]

//reduce() - Combines everything into a single value (like a sum, an object, or a string).
array.reduce((accumulator, currentValue) => {
   return accumulator;
}, initialValue);

const total = [1, 2, 3].reduce((acc, cur) => acc + cur, 0);
console.log(total); // 6

const letters = ['a', 'b', 'a'];
const count = letters.reduce((acc, cur) => {
  acc[cur] = (acc[cur] || 0) + 1;
  return acc;
}, {});
console.log(count); // { a: 2, b: 1 }

//sort() - Reorders the array (ascending or descending).
//Important: It changes the original array unless copied

const scores = [100, 80, 60];
const sorted = [...scores].sort((a, b) => b - a);
console.log(sorted); // [100, 80, 60]
</code></pre>
    </section>


    <section class="topic">
      <h2>27. Callback Functions</h2>
      <p>
        Pass one function as an argument to another function. The passed
        function is then called at a specific time, and this is what is known as
        a callback function.
      </p>
      <pre><code>function greet(name) {
console.log("Hello " + name);
}
function processUser(callback) {
  let user = "Aysen";
  callback(user);
}
processUser(greet); // "Hello Aysen"
// The greet function is being called inside processUser
// callback becomes the greet function.

function calculate(a, b, operation) {
  return operation(a, b);
}
function add(x, y) {
  return x + y;
}
let result = calculate(3, 5, add);
console.log(result); // 8
// 'add' was passed to the 'calculate' function as a callback.

let numbers = [1, 2, 3];
numbers.forEach(function (number) {
  console.log(number * 2);
});
// forEach calls a callback function for each element.
// Callback A function that is passed as an argument to another function.
// However, if they become too deeply nested, the code becomes unreadable.
// For this reason, Promises and async/await are used
</code></pre>
    </section>

    <section class="topic">
      <h2>28. Promises (I Promise, I'll Let You Know When It's Done)</h2>
      <p>
        Manage asynchronous operations, such as fetching data from an API or
        uploading a file. It represents an expected operation and has three
        states: pending - Waiting, fulfilled -Successful (resolve), rejected-
        Failed (reject)
      </p>
      <p>
        It will eventually have a result (success or failure). then() runs on
        success, .catch() runs on failure.
      </p>
      <p>Common methods used with Promises:</p>
      <ul>
        <li>
          <span class="bold">resolve </span> - called when the operation
          completes successfully
        </li>
        <li><span class="bold">reject </span> - called when an error occurs</li>
        <li><span class="bold">.then() </span> - handles a successful result</li>
        <li>
          <span class="bold">.catch() </span> - handles errors or rejections
        </li>
      </ul>
      <pre><code>//Creating a Basic Promise
let promise = new Promise((resolve, reject) => { // Create a Promise with resolve (success) and reject (failure).
let success = true; 
if (success) {
    resolve("Operation successful!"); // Fulfill the promise with a message.
} else {
    reject("An error occurred."); // Reject the promise with an error message.
  }
});

//Using then() and catch()
promise
  .then(function (result) {
    console.log(result); // "Operation successful!"
  })
  .catch(function (error) {
    console.log(error);  // "An error occurred."
  });
// then, runs if the operation is successful.
// catch, runs if an error occurs.

//with setTimeout (Promise with Delay)
function getData() {
  return new Promise(function (resolve, reject) { // Create a Promise
    setTimeout(() => {
      resolve("Data arrived successfully!"); // Fulfill the promise after delay.
    }, 2000); // runs after 2 seconds
  });
}

getData()
  .then(data => console.log(data))
  .catch(error => console.error(error));

//Error Handling
function fetchData() {
  return new Promise((resolve, reject) => {
    let status = false;
    if (status) {
      resolve("Data arrived");
    } else {
      reject("Failed to fetch data");
    }
  });
}
fetchData()
  .then(data => console.log(data))
  .catch(error => console.log("Error:", error));
</code></pre>
    </section>

    <section class="topic">
      <h2>29. Fetching Data with the Fetch API</h2>
      <p>
        The fetch() function allows you to make HTTP requests (fetch(url) -
        sends a network request (GET by default)), such as fetching data (GET)
        or sending data (POST). It's the most common method for fetching JSON
        data from APIs.
      </p>
      <pre><code>//Basic GET Request
fetch("https://jsonplaceholder.typicode.com/posts/1") // Send GET request to get post #1.
.then(res => res.json())  // Convert the incoming response to JSON
.then(data => console.log(data))
.catch(error => console.log("Error:", error)); //(.catch() → handles errors.)

//The res.json() expression returns a Promise, which is why it's handled with .then()   (Returns a Promise that resolves to a Response object.)
.then(response => response.json())

 //GET with Limit & Skip
//limit - how many items to get.
//skip → how many items to skip
fetch("https://dummyjson.com/products?limit=5&skip=10") 
// Get 5 products but skip the first 10 (start from item #11).
  .then(response => response.json()) // Convert response to JS object.
  .then(data => console.log(data)) // Log the products.
  .catch(error => console.error("Error:", error));// Handle request errors.

//POST Request (Sending Data)
fetch("https://jsonplaceholder.typicode.com/posts", { 
  method: "POST", // HTTP method for creating data.
  headers: { "Content-Type": "application/json" }, // Tell server we send JSON.
  body: JSON.stringify({ // Convert JS object to JSON string.
    title: "My Post",
    body: "Hello World",
    userId: 1
  })
})
  .then(response => response.json()) // Convert response to JS object
  .then(data => console.log(data)) // Log created post
  .catch(error => console.error("Error:", error));// Handle request errors.
</code></pre>
    </section>

    <section class="topic">
      <h2>30. HTTP Methods (CRUD)</h2>
      <p>
        HTTP methods define what action you want to perform on the server. They
        are often used with fetch() to work with APIs.
      </p>
      <ul>
        <li><span class="bold">GET </span> Read data (no changes to server)</li>
        <li><span class="bold">POST </span> Create new data</li>
        <li><span class="bold">PUT </span>Replace existing data completely</li>
        <li><span class="bold">PATCH </span>Update part of existing data</li>
        <li><span class="bold">DELETE </span>Remove data</li>
      </ul>

      <pre><code>//GET (Read Data) - Retrieve a specific post
fetch("https://jsonplaceholder.typicode.com/posts/1", { method: "GET" })
  .then(res => res.json()) // Convert response to JSON
  .then(data => console.log("GET:", data)) // Show retrieved post
  .catch(err => console.error("GET Error:", err)); // Handle error

// POST (Create Data)
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST", // Create new data
  headers: { "Content-Type": "application/json" }, // Tell server we send JSON
  body: JSON.stringify({ title: "New Post", body: "Content here", userId: 1 }) // Data to send
})
  .then(res => res.json()) // Convert response to JSON
  .then(data => console.log("POST:", data)) // Show created data
  .catch(err => console.error("POST Error:", err)); // Handle error

// PUT (Replace Data Completely)
fetch("https://jsonplaceholder.typicode.com/posts/1", {
  method: "PUT", // Replace full data
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title: "Updated Post", body: "Updated content", userId: 1 })
})
  .then(res => res.json())
  .then(data => console.log("PUT:", data)) // Show updated post
  .catch(err => console.error("PUT Error:", err)); // Handle error

// PATCH (Update Part of Data)
fetch("https://jsonplaceholder.typicode.com/posts/1", {
  method: "PATCH", // Update only part
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title: "Partially Updated Title" }) // Only title changes
})
  .then(res => res.json())
  .then(data => console.log("PATCH:", data)) // Show updated post
  .catch(err => console.error("PATCH Error:", err)); // Handle error

// DELETE (Remove Data) -Delete a post
fetch("https://jsonplaceholder.typicode.com/posts/1", {
   method: "DELETE" 
  })
  .then(() => console.log("Post deleted successfully")) // No data returned
  .catch(err => console.error("DELETE Error:", err)); // Handle error

//POST/PUT/PATCH usually need a body with JSON data and a "Content-Type": "application/json" header.
</code></pre>
    </section>

    <section class="topic">
      <h2>31. Async / Await</h2>
      <p>
        Async is for writing Promises more easily. async - makes a function
        asynchronous. await - is only used inside an async function. It waits
        for the result of a Promise.
      </p>
      <ul>
        <li>
          <span class="bold">async </span>Tells the function it will return a
          Promise
        </li>
        <li>
          <span class="bold">await </span>Pauses the code until a Promise is
          complete
        </li>
        <li><span class="bold">try / catch </span>Provides error handling</li>
      </ul>

      <pre><code>//Using .then() Without async/await
function fetchData() {
  return new Promise(resolve => {
    setTimeout(() => resolve("Data arrived"), 2000);
  });
}
fetchData().then(data => console.log(data));

//The Same Operation Is Much Simpler with async/await
async function load() {
  // await pauses the function until the Promise is complete
  let result = await fetchData(); 
  console.log(result); // "Data arrived"
}
load();
//await makes the next line wait until the fetchData() function is finished.

//Error Handling - with try / catch
async function load() {
  try {
    let result = await fetchData();
    console.log(result);
  } catch (error) {
    console.log("Error:", error);
  }
}
//The try/catch block works similarly to .catch() but is more readable.

//GET with Async/Await
async function fetchData() {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/posts/1");// Wait for fetch() to finish.
    const data = await response.json();// Convert response to JS object.
    console.log("Post Title",data.title); // Log the post title
  } catch (error) {
    console.log("Error:", error);// Handle fetch errors.
  }
}
fetchData();

//Limit & Skip with Async/Await
async function getProducts(limit, skip) {
  try {
    const response = await fetch(`https://dummyjson.com/products?limit=${limit}&skip=${skip}`);// Fetch products with limit and skip values.
    const data = await response.json();// Convert to JS object.
    console.log(data);// Show the data.
  } catch (error) {
    console.error("Error:", error);// Handle any error.
  }
}
getProducts(5, 10); //getProducts(limit, skip); Get 5 products, starting after the first 10.


// POST with Async/Await
async function sendData() {
  try {
    const res = await fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "POST",
      headers: {"Content-type": "application/json"},
      body: JSON.stringify({
        title: "Hello",
        body: "I am Aysen",
        userId: 1
      })
    });

    const data = await res.json();
    console.log("Sent data:", data);
  } catch (error) {
    console.log("Error:", error);
  }
}
sendData();
</code></pre>
    </section>
  </body>
</html>
